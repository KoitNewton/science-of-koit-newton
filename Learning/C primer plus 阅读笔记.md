# C primer plus 阅读笔记

非正常顺序 具有跳跃性 我觉得没必要写的就略过 毕竟主要面向自己 ——CMY

自行甄别内容正误

## 第十五章  位操作

运算符：~  &   |   ^

<<     >>

&=   |=    ^=   >>=   <<=

### 15.1.2 有符号整数

本来可能会有一些系统使用大端、小端的数据存储模式。

**大端模式：是指一个数据的低位字节序的内容放在高地址处，高位字节序存的内容放在低地址处。**

**小端模式：是指一个数据的低位字节序内容存放在低地址处，高位字节序的内容存放在高地址处。**

现在的CPU基本都是自动兼容上面两种模式的，虽然不同操作系统的选择不一样但是CPU可以兼容。

*补码的表示方法，以一字节为例：*

正值：后七位表示0~127，最高位设置为0；

负值：最高位是1； **一个正值每一位取相反数之后再加一就会得到负值的二进制表示方法。**

如：0000011是3，那么00000011按位取反是11111100，再加1为11111101就是-3。



### 15.1.3 二进制小数

许多分数是不可以使用二进制方法精确表示的这是显然的，因为存在许多的无限不循环小数之类的存在。

举个例子：0.553的二进制表示是什么呢？

二进制小数的小数点之后依次是 $2^{-1},2^{-2},2^{-3}......$ 也就是这些值累加凑成小数的值

```c
#include<stdio.h>
#include<float.h>

float qiu2demi(int n) {
	int i = 0;
	float result = 1;
	for (i = 0; i < n; i++) {
		result /= 2;
	}
	return result;
}

int* print_bin(float n)
{
    int i;
	int shuzi[6] = { 0,0,0,0,0,0 };
	for (i = 0; i < 6; i++) {
		if (n >qiu2demi(i+1)) {
			shuzi[i] = 1;
			n = n - qiu2demi(i+1);
		}
	}
	return &shuzi[0];
}

int main() {

	float a = 3.553;
	int i;
	for (i = 0; i < 6; i++) {	
		printf("%d", *(print_bin(a - (int)a)+i));
	}
	return 0;
}
```



利用上面我写的代码，在float精度为小数点后6位数的情况下运行得到0.553小数点部分是：100011即是0.546875

### 15.3 位操作符

~ 按位取反    &都是1才返回1     | 有一个1就是1      ^ 必须是1和0才返回结果1

那么举例，如何将a=0101?0010的问号的那一位改成值为1？

```c
#include<stdio.h>
#include<float.h>

void main() {

	signed int a = 0b010100010;
	unsigned int b=a | (1 << 4);//1是00000001，左移4位是00010000；
	printf("%u", b);

}
```



输出178，也就是二进制的010110010；

类似的利用掩码、开关、检测之类的操作就是十分显然的了。

### 15.4 位字段

这里是把结构体内部的元素加上位数的限制，类似下面的定义：

```c
struct {
	int a : 5;
	int b : 8;
	unsigned int c : 32;
	_Bool a :1;
} shili;
```

位字段内部的数据类型只能是：_Bool、int、signed int、unsigned int，或者为所选实现版本所提供的类型。这里的类型也可以包含类型限定符。

内部的长度不超过数据类型的最大位数，比如40，40>32是不允许的。

### 15.5 对齐特性（C11)

对齐指的是如何安排对象在内存中的位置。例如，为了效率最大化，系统可能要把一个 double 类型的值储存在4 字节内存地址上，但却允许把char储存在任意地址。

Alignof运算符给出一个类型的对齐要求，在关键字Alignof后面的圆括号中写上类型名即可：
                               size_t d_align = _Alignof(float);
假设d_align的值是4，意思是float类型对象的对齐要求是4。也就是说，4是储存该类型值相邻地址的字节数。一般而言，对齐值都应该是2的非负整
数次幂。就是每隔align设置的字节数的地址存储一笔括号内的数据。

C11在stdlib.h库还添加了一个新的内存分配函数，用于对齐动态分配的内存。该函数的原型如下：
                        void *aligned_alloc(size_t alignment, size_t size);

第1个参数代表指定的对齐，第2个参数是所需的字节数，其值应是第1个参数的倍数。与其他内存分配函数一样，要使用free()函数释放之前分配
的内存。

我个人理解的是，所谓的对齐就是找一块完整的地址连续的内存空间去存放数据。要是是整理出一块完整的空间给代码里的变量的话，得操作其它进程，真是不太可能的我觉得。



